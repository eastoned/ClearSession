import * as t from "three";
import { ShaderLib as o, MeshStandardMaterial as u, MeshPhysicalMaterial as m } from "three";
var x = `#define rnd22(p) fract(sin((p) * mat2(127.1, 311.7, 269.5, 183.3)) * 43758.5453)

#define srgb2rgb(V) pow(max(V, 0.), vec4(2.2)) 
#define rgb2srgb(V) pow(max(V, 0.), vec4(1. / 2.2))

#define C(I)  (srgb2rgb(textureGrad(samp, U / hexTilingPatchScale - rnd22(I), Gx, Gy)) - meanColor * float(hexTilingUseContrastCorrectedBlending))

uniform bool hexTilingUseContrastCorrectedBlending; 
uniform float hexTilingPatchScale;
uniform float hexTilingLookupSkipThreshold;
uniform float hexTilingTextureSampleCoefficientExponent;

vec4 textureNoTileNeyret(sampler2D samp, vec2 uv) {
    mat2 M0 = mat2(1, 0, .5, sqrt(3.) / 2.);
    mat2 M = inverse(M0);
    vec2 U = uv * hexTilingPatchScale / 8. * exp2(4. * 0.2 + 1.);
    vec2 V = M * U;
    vec2 I = floor(V);
    vec2 Gx = dFdx(U / hexTilingPatchScale), Gy = dFdy(U / hexTilingPatchScale);

    vec4 meanColor = hexTilingUseContrastCorrectedBlending ? srgb2rgb(texture(samp, U, 99.)) : vec4(0.);

    vec3 F = vec3(fract(V), 0), W;
    F.z = 1. - F.x - F.y;
    vec4 fragColor = vec4(0.);

    if (F.z > 0.) {
        W = vec3(F.z, F.y, F.x);
        W = pow(W, vec3(hexTilingTextureSampleCoefficientExponent));
        W = W / dot(W, vec3(1.));

        if (W.x > hexTilingLookupSkipThreshold) {
            fragColor += C(I) * W.x;
        }
        if (W.y > hexTilingLookupSkipThreshold) {
            fragColor += C(I + vec2(0, 1)) * W.y;
        }
        if (W.z > hexTilingLookupSkipThreshold) {
            fragColor += C(I + vec2(1, 0)) * W.z;
        }
    } else {
        W = vec3(-F.z, 1. - F.y, 1. - F.x);
        W = pow(W, vec3(hexTilingTextureSampleCoefficientExponent));
        W = W / dot(W, vec3(1.));

        if (W.x > hexTilingLookupSkipThreshold) {
            fragColor += C(I + 1.) * W.x;
        }
        if (W.y > hexTilingLookupSkipThreshold) {
            fragColor += C(I + vec2(1, 0)) * W.y;
        }
        if (W.z > hexTilingLookupSkipThreshold) {
            fragColor += C(I + vec2(0, 1)) * W.z;
        }
    }

    fragColor = hexTilingUseContrastCorrectedBlending ? meanColor + fragColor / length(W) : fragColor;

    fragColor = clamp(rgb2srgb(fragColor), 0., 1.);

    return fragColor;
}`;
const g = "USE_THREE_HEX_TILING", l = (e, n, a) => {
  const r = e.match(n);
  if (!r)
    return e;
  const f = `
#ifdef ${g}
${a}
#else
${r[0]}
#endif
`;
  return e.replace(n, f);
};
let h = !1;
const C = () => {
  t.ShaderChunk.map_fragment = l(
    t.ShaderChunk.map_fragment,
    /texture2D\(\s*map\s*,\s*vMapUv\s*\)/g,
    "textureNoTileNeyret(map, vMapUv)"
  ), t.ShaderChunk.normal_fragment_maps = l(
    t.ShaderChunk.normal_fragment_maps,
    /texture2D\(\s*normalMap\s*,\s*vNormalMapUv\s*\)/g,
    "textureNoTileNeyret(normalMap, vNormalMapUv)"
  ), t.ShaderChunk.roughnessmap_fragment = l(
    t.ShaderChunk.roughnessmap_fragment,
    /texture2D\(\s*roughnessMap\s*,\s*vRoughnessMapUv\s*\)/g,
    "textureNoTileNeyret(roughnessMap, vRoughnessMapUv)"
  ), t.ShaderChunk.metalnessmap_fragment = l(
    t.ShaderChunk.metalnessmap_fragment,
    /texture2D\(\s*metalnessMap\s*,\s*vMetalnessMapUv\s*\)/g,
    "textureNoTileNeyret(metalnessMap, vMetalnessMapUv)"
  ), t.ShaderChunk.tilebreaking_pars_fragment = x;
}, c = (e) => {
  h || (h = !0, C());
  let n = e;
  return n = n.replace(
    "void main() {",
    `
#include <tilebreaking_pars_fragment>

void main() {
`
  ), n;
}, p = () => ({
  hexTilingUseContrastCorrectedBlending: { value: !0 },
  hexTilingPatchScale: { value: 6 },
  hexTilingLookupSkipThreshold: { value: 0.01 },
  hexTilingTextureSampleCoefficientExponent: { value: 8 }
}), i = Object.freeze({
  patchScale: 2,
  useContrastCorrectedBlending: !0,
  lookupSkipThreshold: 0.01,
  textureSampleCoefficientExponent: 8
}), T = () => Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15), S = (e) => function(n, a) {
  const r = T();
  this.hexTilingID = r, e.set(r, n), this.hexTiling && this.hexTiling !== s && (this.defines[g] = "");
}, v = () => function() {
  return this.hexTiling && this.hexTiling !== s ? "1" : "0";
}, k = (e) => function() {
  const a = e.get(this.hexTilingID);
  if (!a)
    return;
  const r = this.hexTiling ?? i;
  a.uniforms.hexTilingPatchScale.value = r.patchScale ?? i.patchScale, a.uniforms.hexTilingUseContrastCorrectedBlending.value = r.useContrastCorrectedBlending ?? i.useContrastCorrectedBlending, a.uniforms.hexTilingLookupSkipThreshold.value = r.lookupSkipThreshold ?? i.lookupSkipThreshold, a.uniforms.hexTilingTextureSampleCoefficientExponent.value = r.textureSampleCoefficientExponent ?? i.textureSampleCoefficientExponent;
}, s = Object.freeze({}), d = (e) => {
  const n = /* @__PURE__ */ new Map();
  e.prototype.onBeforeCompile = S(n), e.prototype.customProgramCacheKey = v(), e.prototype.hexTilingID = "NOT_SET", e.prototype.hexTiling = s, e.prototype.onBeforeRender = k(n);
}, M = () => {
  const e = o.standard.fragmentShader, n = c(e);
  o.standard.fragmentShader = n, Object.assign(o.standard.uniforms, p()), d(u);
}, b = () => {
  const e = o.physical.fragmentShader, n = c(e);
  o.physical.fragmentShader = n, Object.assign(o.physical.uniforms, p()), d(m);
};
b();
M();
