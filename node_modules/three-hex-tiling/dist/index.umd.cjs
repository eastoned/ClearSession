(function(r,o){typeof exports=="object"&&typeof module<"u"?o(require("three")):typeof define=="function"&&define.amd?define(["three"],o):(r=typeof globalThis<"u"?globalThis:r||self,o(r.THREE))})(this,function(r){"use strict";function o(e){const n=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(e){for(const t in e)if(t!=="default"){const a=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(n,t,a.get?a:{enumerable:!0,get:()=>e[t]})}}return n.default=e,Object.freeze(n)}const i=o(r);var u=`#define rnd22(p) fract(sin((p) * mat2(127.1, 311.7, 269.5, 183.3)) * 43758.5453)

#define srgb2rgb(V) pow(max(V, 0.), vec4(2.2)) 
#define rgb2srgb(V) pow(max(V, 0.), vec4(1. / 2.2))

#define C(I)  (srgb2rgb(textureGrad(samp, U / hexTilingPatchScale - rnd22(I), Gx, Gy)) - meanColor * float(hexTilingUseContrastCorrectedBlending))

uniform bool hexTilingUseContrastCorrectedBlending; 
uniform float hexTilingPatchScale;
uniform float hexTilingLookupSkipThreshold;
uniform float hexTilingTextureSampleCoefficientExponent;

vec4 textureNoTileNeyret(sampler2D samp, vec2 uv) {
    mat2 M0 = mat2(1, 0, .5, sqrt(3.) / 2.);
    mat2 M = inverse(M0);
    vec2 U = uv * hexTilingPatchScale / 8. * exp2(4. * 0.2 + 1.);
    vec2 V = M * U;
    vec2 I = floor(V);
    vec2 Gx = dFdx(U / hexTilingPatchScale), Gy = dFdy(U / hexTilingPatchScale);

    vec4 meanColor = hexTilingUseContrastCorrectedBlending ? srgb2rgb(texture(samp, U, 99.)) : vec4(0.);

    vec3 F = vec3(fract(V), 0), W;
    F.z = 1. - F.x - F.y;
    vec4 fragColor = vec4(0.);

    if (F.z > 0.) {
        W = vec3(F.z, F.y, F.x);
        W = pow(W, vec3(hexTilingTextureSampleCoefficientExponent));
        W = W / dot(W, vec3(1.));

        if (W.x > hexTilingLookupSkipThreshold) {
            fragColor += C(I) * W.x;
        }
        if (W.y > hexTilingLookupSkipThreshold) {
            fragColor += C(I + vec2(0, 1)) * W.y;
        }
        if (W.z > hexTilingLookupSkipThreshold) {
            fragColor += C(I + vec2(1, 0)) * W.z;
        }
    } else {
        W = vec3(-F.z, 1. - F.y, 1. - F.x);
        W = pow(W, vec3(hexTilingTextureSampleCoefficientExponent));
        W = W / dot(W, vec3(1.));

        if (W.x > hexTilingLookupSkipThreshold) {
            fragColor += C(I + 1.) * W.x;
        }
        if (W.y > hexTilingLookupSkipThreshold) {
            fragColor += C(I + vec2(1, 0)) * W.y;
        }
        if (W.z > hexTilingLookupSkipThreshold) {
            fragColor += C(I + vec2(0, 1)) * W.z;
        }
    }

    fragColor = hexTilingUseContrastCorrectedBlending ? meanColor + fragColor / length(W) : fragColor;

    fragColor = clamp(rgb2srgb(fragColor), 0., 1.);

    return fragColor;
}`;const c="USE_THREE_HEX_TILING",l=(e,n,t)=>{const a=e.match(n);if(!a)return e;const b=`
#ifdef ${c}
${t}
#else
${a[0]}
#endif
`;return e.replace(n,b)};let g=!1;const m=()=>{i.ShaderChunk.map_fragment=l(i.ShaderChunk.map_fragment,/texture2D\(\s*map\s*,\s*vMapUv\s*\)/g,"textureNoTileNeyret(map, vMapUv)"),i.ShaderChunk.normal_fragment_maps=l(i.ShaderChunk.normal_fragment_maps,/texture2D\(\s*normalMap\s*,\s*vNormalMapUv\s*\)/g,"textureNoTileNeyret(normalMap, vNormalMapUv)"),i.ShaderChunk.roughnessmap_fragment=l(i.ShaderChunk.roughnessmap_fragment,/texture2D\(\s*roughnessMap\s*,\s*vRoughnessMapUv\s*\)/g,"textureNoTileNeyret(roughnessMap, vRoughnessMapUv)"),i.ShaderChunk.metalnessmap_fragment=l(i.ShaderChunk.metalnessmap_fragment,/texture2D\(\s*metalnessMap\s*,\s*vMetalnessMapUv\s*\)/g,"textureNoTileNeyret(metalnessMap, vMetalnessMapUv)"),i.ShaderChunk.tilebreaking_pars_fragment=u},p=e=>{g||(g=!0,m());let n=e;return n=n.replace("void main() {",`
#include <tilebreaking_pars_fragment>

void main() {
`),n},d=()=>({hexTilingUseContrastCorrectedBlending:{value:!0},hexTilingPatchScale:{value:6},hexTilingLookupSkipThreshold:{value:.01},hexTilingTextureSampleCoefficientExponent:{value:8}}),s=Object.freeze({patchScale:2,useContrastCorrectedBlending:!0,lookupSkipThreshold:.01,textureSampleCoefficientExponent:8}),x=()=>Math.random().toString(36).substring(2,15)+Math.random().toString(36).substring(2,15),C=e=>function(n,t){const a=x();this.hexTilingID=a,e.set(a,n),this.hexTiling&&this.hexTiling!==h&&(this.defines[c]="")},S=()=>function(){return this.hexTiling&&this.hexTiling!==h?"1":"0"},T=e=>function(){const t=e.get(this.hexTilingID);if(!t)return;const a=this.hexTiling??s;t.uniforms.hexTilingPatchScale.value=a.patchScale??s.patchScale,t.uniforms.hexTilingUseContrastCorrectedBlending.value=a.useContrastCorrectedBlending??s.useContrastCorrectedBlending,t.uniforms.hexTilingLookupSkipThreshold.value=a.lookupSkipThreshold??s.lookupSkipThreshold,t.uniforms.hexTilingTextureSampleCoefficientExponent.value=a.textureSampleCoefficientExponent??s.textureSampleCoefficientExponent},h=Object.freeze({}),f=e=>{const n=new Map;e.prototype.onBeforeCompile=C(n),e.prototype.customProgramCacheKey=S(),e.prototype.hexTilingID="NOT_SET",e.prototype.hexTiling=h,e.prototype.onBeforeRender=T(n)},v=()=>{const e=r.ShaderLib.standard.fragmentShader,n=p(e);r.ShaderLib.standard.fragmentShader=n,Object.assign(r.ShaderLib.standard.uniforms,d()),f(r.MeshStandardMaterial)};(()=>{const e=r.ShaderLib.physical.fragmentShader,n=p(e);r.ShaderLib.physical.fragmentShader=n,Object.assign(r.ShaderLib.physical.uniforms,d()),f(r.MeshPhysicalMaterial)})(),v()});
