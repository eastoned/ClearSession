{
  "version": 3,
  "sources": ["../../three-hex-tiling/dist/index.js"],
  "sourcesContent": ["import * as t from \"three\";\nimport { ShaderLib as o, MeshStandardMaterial as u, MeshPhysicalMaterial as m } from \"three\";\nvar x = `#define rnd22(p) fract(sin((p) * mat2(127.1, 311.7, 269.5, 183.3)) * 43758.5453)\n\n#define srgb2rgb(V) pow(max(V, 0.), vec4(2.2)) \n#define rgb2srgb(V) pow(max(V, 0.), vec4(1. / 2.2))\n\n#define C(I)  (srgb2rgb(textureGrad(samp, U / hexTilingPatchScale - rnd22(I), Gx, Gy)) - meanColor * float(hexTilingUseContrastCorrectedBlending))\n\nuniform bool hexTilingUseContrastCorrectedBlending; \nuniform float hexTilingPatchScale;\nuniform float hexTilingLookupSkipThreshold;\nuniform float hexTilingTextureSampleCoefficientExponent;\n\nvec4 textureNoTileNeyret(sampler2D samp, vec2 uv) {\n    mat2 M0 = mat2(1, 0, .5, sqrt(3.) / 2.);\n    mat2 M = inverse(M0);\n    vec2 U = uv * hexTilingPatchScale / 8. * exp2(4. * 0.2 + 1.);\n    vec2 V = M * U;\n    vec2 I = floor(V);\n    vec2 Gx = dFdx(U / hexTilingPatchScale), Gy = dFdy(U / hexTilingPatchScale);\n\n    vec4 meanColor = hexTilingUseContrastCorrectedBlending ? srgb2rgb(texture(samp, U, 99.)) : vec4(0.);\n\n    vec3 F = vec3(fract(V), 0), W;\n    F.z = 1. - F.x - F.y;\n    vec4 fragColor = vec4(0.);\n\n    if (F.z > 0.) {\n        W = vec3(F.z, F.y, F.x);\n        W = pow(W, vec3(hexTilingTextureSampleCoefficientExponent));\n        W = W / dot(W, vec3(1.));\n\n        if (W.x > hexTilingLookupSkipThreshold) {\n            fragColor += C(I) * W.x;\n        }\n        if (W.y > hexTilingLookupSkipThreshold) {\n            fragColor += C(I + vec2(0, 1)) * W.y;\n        }\n        if (W.z > hexTilingLookupSkipThreshold) {\n            fragColor += C(I + vec2(1, 0)) * W.z;\n        }\n    } else {\n        W = vec3(-F.z, 1. - F.y, 1. - F.x);\n        W = pow(W, vec3(hexTilingTextureSampleCoefficientExponent));\n        W = W / dot(W, vec3(1.));\n\n        if (W.x > hexTilingLookupSkipThreshold) {\n            fragColor += C(I + 1.) * W.x;\n        }\n        if (W.y > hexTilingLookupSkipThreshold) {\n            fragColor += C(I + vec2(1, 0)) * W.y;\n        }\n        if (W.z > hexTilingLookupSkipThreshold) {\n            fragColor += C(I + vec2(0, 1)) * W.z;\n        }\n    }\n\n    fragColor = hexTilingUseContrastCorrectedBlending ? meanColor + fragColor / length(W) : fragColor;\n\n    fragColor = clamp(rgb2srgb(fragColor), 0., 1.);\n\n    return fragColor;\n}`;\nconst g = \"USE_THREE_HEX_TILING\", l = (e, n, a) => {\n  const r = e.match(n);\n  if (!r)\n    return e;\n  const f = `\n#ifdef ${g}\n${a}\n#else\n${r[0]}\n#endif\n`;\n  return e.replace(n, f);\n};\nlet h = !1;\nconst C = () => {\n  t.ShaderChunk.map_fragment = l(\n    t.ShaderChunk.map_fragment,\n    /texture2D\\(\\s*map\\s*,\\s*vMapUv\\s*\\)/g,\n    \"textureNoTileNeyret(map, vMapUv)\"\n  ), t.ShaderChunk.normal_fragment_maps = l(\n    t.ShaderChunk.normal_fragment_maps,\n    /texture2D\\(\\s*normalMap\\s*,\\s*vNormalMapUv\\s*\\)/g,\n    \"textureNoTileNeyret(normalMap, vNormalMapUv)\"\n  ), t.ShaderChunk.roughnessmap_fragment = l(\n    t.ShaderChunk.roughnessmap_fragment,\n    /texture2D\\(\\s*roughnessMap\\s*,\\s*vRoughnessMapUv\\s*\\)/g,\n    \"textureNoTileNeyret(roughnessMap, vRoughnessMapUv)\"\n  ), t.ShaderChunk.metalnessmap_fragment = l(\n    t.ShaderChunk.metalnessmap_fragment,\n    /texture2D\\(\\s*metalnessMap\\s*,\\s*vMetalnessMapUv\\s*\\)/g,\n    \"textureNoTileNeyret(metalnessMap, vMetalnessMapUv)\"\n  ), t.ShaderChunk.tilebreaking_pars_fragment = x;\n}, c = (e) => {\n  h || (h = !0, C());\n  let n = e;\n  return n = n.replace(\n    \"void main() {\",\n    `\n#include <tilebreaking_pars_fragment>\n\nvoid main() {\n`\n  ), n;\n}, p = () => ({\n  hexTilingUseContrastCorrectedBlending: { value: !0 },\n  hexTilingPatchScale: { value: 6 },\n  hexTilingLookupSkipThreshold: { value: 0.01 },\n  hexTilingTextureSampleCoefficientExponent: { value: 8 }\n}), i = Object.freeze({\n  patchScale: 2,\n  useContrastCorrectedBlending: !0,\n  lookupSkipThreshold: 0.01,\n  textureSampleCoefficientExponent: 8\n}), T = () => Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15), S = (e) => function(n, a) {\n  const r = T();\n  this.hexTilingID = r, e.set(r, n), this.hexTiling && this.hexTiling !== s && (this.defines[g] = \"\");\n}, v = () => function() {\n  return this.hexTiling && this.hexTiling !== s ? \"1\" : \"0\";\n}, k = (e) => function() {\n  const a = e.get(this.hexTilingID);\n  if (!a)\n    return;\n  const r = this.hexTiling ?? i;\n  a.uniforms.hexTilingPatchScale.value = r.patchScale ?? i.patchScale, a.uniforms.hexTilingUseContrastCorrectedBlending.value = r.useContrastCorrectedBlending ?? i.useContrastCorrectedBlending, a.uniforms.hexTilingLookupSkipThreshold.value = r.lookupSkipThreshold ?? i.lookupSkipThreshold, a.uniforms.hexTilingTextureSampleCoefficientExponent.value = r.textureSampleCoefficientExponent ?? i.textureSampleCoefficientExponent;\n}, s = Object.freeze({}), d = (e) => {\n  const n = /* @__PURE__ */ new Map();\n  e.prototype.onBeforeCompile = S(n), e.prototype.customProgramCacheKey = v(), e.prototype.hexTilingID = \"NOT_SET\", e.prototype.hexTiling = s, e.prototype.onBeforeRender = k(n);\n}, M = () => {\n  const e = o.standard.fragmentShader, n = c(e);\n  o.standard.fragmentShader = n, Object.assign(o.standard.uniforms, p()), d(u);\n}, b = () => {\n  const e = o.physical.fragmentShader, n = c(e);\n  o.physical.fragmentShader = n, Object.assign(o.physical.uniforms, p()), d(m);\n};\nb();\nM();\n"],
  "mappings": "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",
  "names": []
}
